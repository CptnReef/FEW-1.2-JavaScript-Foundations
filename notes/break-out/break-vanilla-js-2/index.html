<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Gamedev Canvas Workshop</title>
  <style>
    * {
      padding: 0;
      margin: 0;
    }

    canvas {
      background: #eee;
      display: block;
      margin: 0 auto;
    }

  </style>
</head>

<body>
  
  <!-- 

  Challenges
  
1) Get the tutorial working 
2) Play the game
3) OOP - Use Classes to define Game Objects
  - Convert ball, paddle, and bricks to Class object
  - Convert Score and Life Counter to class Objects
4) Dependency Injection - Render better!
  - Give each of your classes a render method that takes 
  the rendering context as a parameter. Each object 
  renders itself to the context.

Stretch Goals 
  
1) Change the colors of the bricks, ball, and paddle
2) Change the background
3) Create a game over message that appears in game, that is replace
the alert message with something that displays in canvas. 
4) Start with one row of bricks, then add another row as each level
is completed. 
5) Make each row of bricks a different color. 

  -->

  <canvas id="myCanvas" width="480" height="320"></canvas>

  <script>
    // JavaScript code goes here
    document.addEventListener("keydown", keyDownHandler, false);
    document.addEventListener("keyup", keyUpHandler, false);
    document.addEventListener("mousemove", mouseMoveHandler, false);

    const canvas = document.getElementById("myCanvas");
    const ctx = canvas.getContext("2d");

    var x = canvas.width / 2;
    var y = canvas.height - 30;

    var score = 0;
    var lives = 3;

    var dx = 2;
    var dy = -2;

    // ---------------------------------------------------
    // Ball

    class Ball {
      constructor(radius) {
        this.radius = radius;
        this.color = "#0095DD";
      }

      render(ctx) {
        ctx.beginPath();
        ctx.arc(x, y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.closePath();
      }
    }

    var ballRadius = 10;
    const ball = new Ball(ballRadius);

    var paddleHeight = 10;
    var paddleWidth = 75;
    var paddleX = (canvas.width - paddleWidth) / 2;
    var rightPressed = false;
    var leftPressed = false;


    // ----------------------------------------------
    // Brick

    class Brick {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.status = 1;
      }

      render(ctx) {
        ctx.beginPath();
        ctx.rect(this.x, this.y, brickWidth, brickHeight);
        ctx.fillStyle = "#95DD00";
        ctx.fill();
        ctx.closePath();
      }
    }

    var brickRowCount = 3;
    var brickColumnCount = 5;
    var brickWidth = 75;
    var brickHeight = 20;
    var brickPadding = 10;
    var brickOffsetTop = 30;
    var brickOffsetLeft = 30;

    var bricks = [];
    for (var c = 0; c < brickColumnCount; c++) {
      bricks[c] = [];
      for (var r = 0; r < brickRowCount; r++) {
        bricks[c][r] = new Brick();
      }
    }

    function drawBall() {
      ball.render(ctx);
    }

    function drawPaddle() {
      ctx.beginPath();
      ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
      ctx.fillStyle = "#0095DD";
      ctx.fill();
      ctx.closePath();
    }

    function drawBricks() {
      for (var c = 0; c < brickColumnCount; c++) {
        for (var r = 0; r < brickRowCount; r++) {
          if (bricks[c][r].status == 1) {
            var brickX = (c * (brickWidth + brickPadding)) + brickOffsetLeft;
            var brickY = (r * (brickHeight + brickPadding)) + brickOffsetTop;
            bricks[c][r].x = brickX;
            bricks[c][r].y = brickY;
            bricks[c][r].render(ctx);
//            ctx.beginPath();
//            ctx.rect(brickX, brickY, brickWidth, brickHeight);
//            ctx.fillStyle = "#0095DD";
//            ctx.fill();
//            ctx.closePath();
          }
        }
      }
    }

    function collisionDetection() {
      for (var c = 0; c < brickColumnCount; c++) {
        for (var r = 0; r < brickRowCount; r++) {
          var b = bricks[c][r];
          if (b.status == 1) {
            if (x > b.x && x < b.x + brickWidth && y > b.y && y < b.y + brickHeight) {
              dy = -dy;
              b.status = 0;
              score += 1;
              if (score == brickRowCount * brickColumnCount) {
                alert("YOU WIN, CONGRATULATIONS!");
                document.location.reload();
              }
            }
          }
        }
      }
    }

    function drawScore() {
      ctx.font = "16px Arial";
      ctx.fillStyle = "#0095DD";
      ctx.fillText("Score: " + score, 8, 20);
    }

    function drawLives() {
      ctx.font = "16px Arial";
      ctx.fillStyle = "#0095DD";
      ctx.fillText("Lives: " + lives, canvas.width - 65, 20);
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBricks();
      drawBall();
      drawPaddle();
      drawScore();
      drawLives();
      collisionDetection();

      if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) {
        dx = -dx;
      }

      if (y + dy < ballRadius) {
        dy = -dy;
      } else if (y + dy > canvas.height - ballRadius) {
        if (x > paddleX && x < paddleX + paddleWidth) {
          dy = -dy;
        } else {
          lives--;
          if (!lives) {
            alert("GAME OVER");
            x = 200;
            y = 200;
            document.location.reload();
          } else {
            x = canvas.width / 2;
            y = canvas.height - 30;
            dx = 2;
            dy = -2;
            paddleX = (canvas.width - paddleWidth) / 2;
          }
        }
      }

      x += dx;
      y += dy;

      if (rightPressed && paddleX < canvas.width - paddleWidth) {
        paddleX += 7;
      } else if (leftPressed && paddleX > 0) {
        paddleX -= 7;
      }

      requestAnimationFrame(draw);
    }

    function keyDownHandler(e) {
      if (e.keyCode == 39) {
        rightPressed = true;
      } else if (e.keyCode == 37) {
        leftPressed = true;
      }
    }

    function keyUpHandler(e) {
      if (e.keyCode == 39) {
        rightPressed = false;
      } else if (e.keyCode == 37) {
        leftPressed = false;
      }
    }

    function mouseMoveHandler(e) {
      var relativeX = e.clientX - canvas.offsetLeft;
      if (relativeX > 0 && relativeX < canvas.width) {
        paddleX = relativeX - paddleWidth / 2;
      }
    }

    draw();

  </script>

</body>

</html>
