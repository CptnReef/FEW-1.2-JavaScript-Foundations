<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Gamedev Canvas Workshop</title>
  <style>
    * {
      padding: 0;
      margin: 0;
    }

    canvas {
      background: #eee;
      display: block;
      margin: 0 auto;
    }

  </style>
</head>

<body>
  
  <!-- 

  Challenges
  
1) Get the tutorial working 
2) Play the game
3) OOP - Use Classes to define Game Objects
  - Convert ball, paddle, and bricks to Class object
  - Convert Score and Life Counter to class Objects
4) Dependency Injection - Render better!
  - Give each of your classes a render method that takes 
  the rendering context as a parameter. Each object 
  renders itself to the context.

Stretch Goals 
  
1) Change the colors of the bricks, ball, and paddle
2) Change the background
3) Start with one row of bricks, then add another row as each level
is completed.
4) Make each row of bricks a different color. 
5) Create a game over message that appears in game, that is replace
the alert message with something that displays in canvas. 
  - Make a Button class that listens for click events on canvas and checks to see if they are within the area of the button. 
  - Button can display a label string
  - Button has a hover and active states. Changes color on hover and when the mouse is down over the button. 
  - Button handles hover and active events. 
6) Move the ball on a vector. There are several ways to handle this. 
  - Give the ball a direction or angle in degrees or radians
  - Give the ball a speed
  - calculate the x and y using sine and cosine of the angle/direction https://stackoverflow.com/questions/40472364/moving-object-from-a-to-b-smoothly-across-canvas
  - As the ball bounces off another object the angle needs to be recalculated. https://www.oreilly.com/library/view/html5-canvas/9781449308032/ch05s02.html
7) Improve the collision detection.
  - There are two routes you can choose
    - Easier: Look up rectangle rectangle collision
    - Harder: Look up circle rectangle collision
8) Make it gooey - https://www.visualcinnamon.com/2016/06/fun-data-visualizations-svg-gooey-effect.html

  -->

  <canvas id="myCanvas" width="480" height="320"></canvas>

  <script>
    
    // JavaScript code goes here
    document.addEventListener("keydown", keyDownHandler, false);
    document.addEventListener("keyup", keyUpHandler, false);
    document.addEventListener("mousemove", mouseMoveHandler, false);

    
    const canvas = document.getElementById("myCanvas");
    const ctx = canvas.getContext("2d");

    var x = canvas.width / 2;
    var y = canvas.height - 30;

    var score = 0;
    var lives = 30000; // 

    var dx = 2;
    var dy = -2;

    // ---------------------------------------------------
    // Ball

    class Ball {
      constructor(radius, color = "#0095DD") {
        this.radius = radius;
        this.color = color;
      }
      
      render(ctx) {
        ctx.beginPath();
        ctx.arc(x, y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.closePath();
      }
    }
    
    class Ball2 {
      constructor(radius, x = 0, y = 0, color = "#0095DD") {
        this.radius = radius;
        this.color = color;
        this.x = x;
        this.y = y;
        this.speed = 1;
        this.direction = Math.random() * Math.PI * 2;
      }
      
      move() {
        this.x += Math.cos(this.direction) * this.speed;
        this.y += Math.sin(this.direction) * this.speed;
        if (this.x > 480 || this.x < 0) {
            this.direction = Math.PI - this.direction;
        } else if (this.y > 320 || this.y < 0) {
          this.direction = Math.PI * 2 - this.direction;
        }
      }

      render(ctx) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.closePath();
      }
    }

    // ----------------------------------------------
    
    var ballRadius = 10;
    const ball = new Ball(ballRadius);
    const redBall = new Ball2(ballRadius, 100, 300, 'red');

    var paddleHeight = 10;
    var paddleWidth = 75;
    var paddleX = (canvas.width - paddleWidth) / 2;
    var rightPressed = false;
    var leftPressed = false;

    // ================================================
    // Canvas Button 
    
    class Button {
      constructor(canvas, x, y, w, h, label, color = '#000', labelColor = '#fff') {
        this.x = x;
        this.y = y;
        this.width = w;
        this.height = h; 
        this.color = color;
        this.labelColor = labelColor;
        this.label = label;
        this.canvas = canvas;
        
        this.canvas.addEventListener('click', (e) => {
          this.handleClick(e);
        });
      }
      
      handleClick(e) {
        const rect = canvas.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const clickY = e.clientY - rect.top;

        if (clickX >= this.x && clickX <= this.x + this.width && 
            clickY >= this.y && clickY <= this.y + this.height) {
          
          console.log('Click:', this.label, clickX, clickY);
        }
      }
      
      render(ctx) {
        ctx.beginPath();
        ctx.rect(this.x, this.y, this.width, this.height);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.closePath();
        ctx.font = 'Helvetic';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = this.labelColor;
        ctx.fillText(this.label, this.x + this.width / 2, this.y + this.height / 2);
      }
    }
    
    const button = new Button(canvas, 200, 220, 100, 40, 'Hello');
    
    // ==============================================
    
    
    class Iterator {
      
    }
    
    class Particle {
      constructor(x, y, size) {
        this.x = x;
        this.y = y;
        this.size = size;
        this.radius = size;
        this.t = size;
        this.speed = Math.random() * 10 - 5;
        this.angle = Math.random() * Math.PI * 2;
      }
      
      move(ctx) {
        const w = ctx.canvas.clientWidth;
        const h = ctx.canvas.clientHeight;
        
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;
        
        if (this.x < 0) {
            this.x += w;
        } else if (this.x > w) {
          this.x -= w;          
        }
        
        if (this.y < 0) {
          this.y += h
        } else if (this.y > h) {
          this.y -= h
        } 
      }
      
      scale() {
        this.t += this.speed * 0.01;
        this.size = Math.abs(Math.sin(this.t) * this.radius);
      }
      
      render(ctx) {
        ctx.fillStyle = '#ff00ff44';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, 2 * Math.PI);
        ctx.fill();
      }
    }
    
    class ParticleSwarm {
      constructor(count = 100) {
        this.particles = [];
    
        for (let n = 0; n < count; n += 1) {
          const x = Math.random() * 400;
          const y = Math.random() * 400;
          const size = Math.random() * 40
          this.particles.push(new Particle(x, y, size));
        }
      }
      
      particleIterator() {
        let index = 0;
        let result;
        return { 
          next: () => {
            if (index < this.particles.length - 1) {
              result = { value: this.particles[index], done: false };
              index += 1;
            } else if (index === this.particles.length - 1) {
              result = { value: this.particles[index], done: true };
            } else {
              result = { done: true }
            }
            
            return result;
          }
        }
      }
      
      render(ctx) {
        const it = this.particleIterator();
        let result = it.next();
        while(!result.done) {
          const particle = result.value;
          // particle.move(ctx);
          particle.scale();
          particle.render(ctx);
          result = it.next();
        }
        
//        for (let p in this.particles) {
//          const particle = this.particles[p];
//          // particle.move(ctx);
//          particle.scale();
//          particle.render(ctx);
//        }
      }
    }
    
    let swarm = new ParticleSwarm()
    
    

    // ----------------------------------------------
    // Brick

    class Brick {
      constructor(x, y, color = "#95DD00") {
        this.x = x;
        this.y = y;
        this.status = 1;
        this.color = color;
      }

      render(ctx) {
        ctx.beginPath();
        ctx.rect(this.x, this.y, brickWidth, brickHeight);
        ctx.fillStyle = this.color;
        ctx.fill();
//        ctx.closePath();
      }
    }

    var brickRowCount = 3;
    var brickColumnCount = 5;
    var brickWidth = 75;
    var brickHeight = 20;
    var brickPadding = 10;
    var brickOffsetTop = 30;
    var brickOffsetLeft = 30;

    var bricks = [];
    for (var c = 0; c < brickColumnCount; c++) {
      bricks[c] = [];
      for (var r = 0; r < brickRowCount; r++) {
        bricks[c][r] = new Brick();
      }
    }

    
    
    // Draw ball 
    
    function drawBall() {
      ball.render(ctx);
      redBall.move()
      redBall.render(ctx);
      button.render(ctx);
    }
    
    
    
    

    function drawPaddle() {
      ctx.beginPath();
      ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
      ctx.fillStyle = "#0095DD";
      ctx.fill();
//      ctx.closePath();
    }

    function drawBricks() {
      for (var c = 0; c < brickColumnCount; c++) {
        for (var r = 0; r < brickRowCount; r++) {
          if (bricks[c][r].status == 1) {
            var brickX = (c * (brickWidth + brickPadding)) + brickOffsetLeft;
            var brickY = (r * (brickHeight + brickPadding)) + brickOffsetTop;
            bricks[c][r].x = brickX;
            bricks[c][r].y = brickY;
            bricks[c][r].render(ctx);
          }
        }
      }
    }

    function collisionDetection() {
      for (var c = 0; c < brickColumnCount; c++) {
        for (var r = 0; r < brickRowCount; r++) {
          var b = bricks[c][r];
          if (b.status == 1) {
            if (x > b.x && x < b.x + brickWidth && y > b.y && y < b.y + brickHeight) {
              dy = -dy;
              b.status = 0;
              score += 1;
              if (score == brickRowCount * brickColumnCount) {
                // alert("YOU WIN, CONGRATULATIONS!");
                // document.location.reload();
              }
            }
          }
        }
      }
    }

    function drawScore() {
      ctx.font = "16px Arial";
      ctx.fillStyle = "#0095DD";
      ctx.textAlign = 'left';
      ctx.fillText("Score: " + score, 20, 20);
    }

    function drawLives() {
      ctx.font = "16px Arial";
      ctx.fillStyle = "#0095DD";
      ctx.textAlign = 'right';
      ctx.fillText("Lives: " + lives, canvas.width - 20, 20);
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      swarm.render(ctx);
      drawBricks();
      drawBall();
      drawPaddle();
      drawScore();
      drawLives();
      collisionDetection();
      
      // Bounce ball off edges 
      if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) {
        dx = -dx;
      }

      if (y + dy < ballRadius) {
        dy = -dy;
      } else if (y + dy > canvas.height - ballRadius) {
        if (x > paddleX && x < paddleX + paddleWidth) {
          dy = -dy;
        } else {
          lives--;
          if (!lives) {
            // alert("GAME OVER");
            x = 200;
            y = 200;
            // document.location.reload();
          } else {
            x = canvas.width / 2;
            y = canvas.height - 30;
            dx = 2;
            dy = -2;
            paddleX = (canvas.width - paddleWidth) / 2;
          }
        }
      }

      // Move ball 
      x += dx;
      y += dy;
      

      if (rightPressed && paddleX < canvas.width - paddleWidth) {
        paddleX += 7;
      } else if (leftPressed && paddleX > 0) {
        paddleX -= 7;
      }

      requestAnimationFrame(draw);
    }

    function keyDownHandler(e) {
      if (e.keyCode == 39) {
        rightPressed = true;
      } else if (e.keyCode == 37) {
        leftPressed = true;
      }
    }

    function keyUpHandler(e) {
      if (e.keyCode == 39) {
        rightPressed = false;
      } else if (e.keyCode == 37) {
        leftPressed = false;
      }
    }

    function mouseMoveHandler(e) {
      var relativeX = e.clientX - canvas.offsetLeft;
      if (relativeX > 0 && relativeX < canvas.width) {
        paddleX = relativeX - paddleWidth / 2;
      }
    }

    draw();

  </script>

</body>

</html>
